<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Andy Arvanitis]]></title>
  <link href="http://andyarvanitis.com/atom.xml" rel="self"/>
  <link href="http://andyarvanitis.com/"/>
  <updated>2017-03-03T13:29:55-08:00</updated>
  <id>http://andyarvanitis.com/</id>
  <author>
    <name><![CDATA[Andy Arvanitis]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[An FFI example for PureScript C++: PCRE]]></title>
    <link href="http://andyarvanitis.com/an-ffi-example-for-purescript-c-plus-plus-pcre/"/>
    <updated>2017-01-03T15:10:00-08:00</updated>
    <id>http://andyarvanitis.com/an-ffi-example-for-purescript-c-plus-plus-pcre</id>
    <content type="html"><![CDATA[<p>In case you haven’t read it, for a brief overview of the PureScript C++ FFI please see my guest post in “24 Days of PureScript 2016”, <a href="https://github.com/paf31/24-days-of-purescript-2016/blob/master/19.markdown">Day 19 – Intro to the C++ FFI</a>.</p>

<p>In this post, I&rsquo;ll demonstrate one way to tackle interop with a not-too-trivial C library, namely “Perl Compatible Regular Expressions”, a.k.a. <a href="http://www.pcre.org/">PCRE</a>. I don&rsquo;t actually have much experience with this library, but I was inspired to try creating bindings for it after recently re-reading Chapter 17: “Interfacing with C: The FFI” from <a href="http://book.realworldhaskell.org/"><em>Real World Haskell</em></a> by Bryan O&#8217;Sullivan, Don Stewart, and John Goerzen.</p>

<p>As this post borrows both the motivation and specific example from the book, please keep the following in mind:</p>

<ol>
<li>This is <strong>not</strong> a “PureScript is better at this than Haskell” post</li>
<li>This is not necessarily the best way to use the PCRE library or create PureScript bindings for it</li>
<li>The referenced Haskell example from the book is not necessarily the only way to do things in Haskell (see item 1)</li>
</ol>


<p>With that out of the way, the other thing I&rsquo;d like to point out is that I will use the same C API of the PCRE library that was used in the book, even though I&rsquo;m aware a newer version exists (pcre2), as does a C++ version. But again, please see items 1-3 above!</p>

<h3>The Goal</h3>

<p>Create the minimal bindings needed to use functions <code>pcre_compile</code> and <code>pcre_exec</code> in a simple example.</p>

<h3>Declare the foreign types and functions on the PureScript side</h3>

<p>This signature of C function <code>pcre_compile</code> looks like this:</p>

<figure class='code'><div class="highlight"><pre class="code"><code class = "#{lang}"><span class="n">pcre</span> <span class="o">*</span><span class="nf">pcre_compile</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">pattern</span><span class="p">,</span>
                   <span class="kt">int</span> <span class="n">options</span><span class="p">,</span>
                   <span class="k">const</span> <span class="kt">char</span> <span class="o">**</span><span class="n">errptr</span><span class="p">,</span>
                   <span class="kt">int</span> <span class="o">*</span><span class="n">erroffset</span><span class="p">,</span>
                   <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">tableptr</span><span class="p">);</span>
</code></pre></div></figure>


<p>The approach I&rsquo;ve chosen to take is to create a simplified and pure<a href="#footnote"><sup>1</sup></a> PureScript C++ wrapper function for <code>pcre_compile</code> which simply takes a string and options, and returns either an error string or a valid (foreign, opaque) <code>pcre</code> object. PureScript strings are native strings, so that means the only foreign types we need to declare are for the options and the <code>pcre</code> compiled code object:</p>

<figure class='code'><div class="highlight"><pre class="code"><code class = "#{lang}"><span class="nf">foreign</span> <span class="kr">import</span> <span class="nn">data</span> <span class="kt">PCREOption</span> <span class="ow">::</span> <span class="o">*</span>
<span class="nf">foreign</span> <span class="kr">import</span> <span class="nn">data</span> <span class="kt">PCRECode</span> <span class="ow">::</span> <span class="o">*</span>
</code></pre></div></figure>


<p>Note that <code>PCREOption</code> happens to be a C <code>int</code>, so we could have treated it that way on the PureScript side too and simply used <code>Int</code>, but I chose to abstract away that particular detail.</p>

<p>The <code>PCREOption</code> type can have a number of (constant) values, so let&rsquo;s declare a couple of them for this exercise:</p>

<figure class='code'><div class="highlight"><pre class="code"><code class = "#{lang}"><span class="nf">foreign</span> <span class="kr">import</span> <span class="nn">caseless</span> <span class="ow">::</span> <span class="kt">PCREOption</span>
<span class="nf">foreign</span> <span class="kr">import</span> <span class="nn">dotall</span>   <span class="ow">::</span> <span class="kt">PCREOption</span>
</code></pre></div></figure>


<p>We can now declare our wrapper function in terms of these imported foreign types:</p>

<figure class='code'><div class="highlight"><pre class="code"><code class = "#{lang}"><span class="nf">foreign</span> <span class="kr">import</span> <span class="nn">compile</span> <span class="ow">::</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">Array</span> <span class="kt">PCREOption</span> <span class="ow">-&gt;</span> <span class="kt">Either</span> <span class="kt">String</span> <span class="kt">PCRECode</span>
</code></pre></div></figure>


<p>We&rsquo;ll use a similar approach for the wrapper for <code>pcre_exec</code> and another function, <code>capturedCount</code>, but please see the full source later in the post for those details.</p>

<h3>Implement the foreign wrapper functions on the C++ side</h3>

<p>Let&rsquo;s jump right to the code:</p>

<figure class='code'><div class="highlight"><pre class="code"><code class = "#{lang}"><span class="k">enum</span> <span class="p">{</span>
  <span class="n">caseless</span> <span class="o">=</span> <span class="n">PCRE_CASELESS</span><span class="p">,</span>
  <span class="n">dotall</span>   <span class="o">=</span> <span class="n">PCRE_DOTALL</span>
<span class="p">};</span>
</code></pre></div></figure>


<p>The foreign options we declared earlier are defined here as <code>enum</code>s (<code>int</code>s) taking on <code>#define</code> constant values from the PCRE library. If they weren&rsquo;t capitalized, we wouldn&rsquo;t have needed them at all; the PureScript imports alone would have been sufficient.</p>

<figure class='code'><div class="highlight"><pre class="code"><code class = "#{lang}"><span class="k">auto</span> <span class="n">compile</span><span class="p">(</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">pattern</span><span class="p">,</span> <span class="k">const</span> <span class="n">any</span><span class="o">::</span><span class="n">array</span><span class="o">&amp;</span> <span class="n">options</span> <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">any</span> <span class="p">{</span>
  <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">err</span> <span class="o">=</span> <span class="n">nullptr</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">erroffset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">auto</span> <span class="n">ptr</span> <span class="o">=</span> <span class="n">pcre_compile</span><span class="p">(</span><span class="n">pattern</span><span class="p">,</span>
                          <span class="n">bitor_all</span><span class="p">(</span><span class="n">options</span><span class="p">),</span>
                          <span class="o">&amp;</span><span class="n">err</span><span class="p">,</span>
                          <span class="o">&amp;</span><span class="n">erroffset</span><span class="p">,</span>
                          <span class="n">nullptr</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">ptr</span> <span class="o">?</span> <span class="n">Right</span><span class="p">(</span><span class="n">managed</span><span class="o">&lt;</span><span class="n">pcre</span><span class="o">&gt;</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="n">pcre_free</span><span class="p">))</span> <span class="o">:</span> <span class="n">Left</span><span class="p">(</span><span class="n">err</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></figure>


<p>The idea here is to have a straightforward-as-possible wrapper function that calls <code>pcre_compile</code>. We want to minimize any logic here, keeping any sophisticated decision-making on the PureScript side, where things are much more type safe. As mentioned earlier, I&rsquo;ve also chosen to implement this wrapper as a pure function which does not mutate any non-local data.</p>

<p>The call to <code>pcre_compile</code> is pretty simple, but the last line has a couple of interesting things going on. The final return value depends on whether the pointer to the <code>pcre</code> object returned from <code>pcre_compile</code> is <code>NULL</code> or not:</p>

<ul>
<li><p>If it is <code>NULL</code>, the <code>err</code> (error) C-style string is implicitly copied and put into a PureScript <code>Left</code> data value from the familiar <code>Either</code> module. Both the new string and the <code>Left</code>&rsquo;s memory are automatically managed by PureScript.</p></li>
<li><p>If it isn&rsquo;t <code>NULL</code>, the <code>pcre</code> object is stored as a managed pointer, meaning that the PureScript runtime will take ownership of its lifetime. When it is time to release/destroy it, I&rsquo;ve specified here that it will call <code>pcre_free</code> (from the PCRE library) to do the actual freeing. In turn, a <code>Right</code> is constructed with this value.</p></li>
</ul>


<div style="position: relative; top: -2em;">
Note that one of the nice things about using the <strong>Either</strong> type like this is that the Either PureScript module didn&#8217;t explicitly expose these constructors via FFI functions – it&#8217;s just a benefit of the compiler targeting/generating C++ code.
</div>


<h3>Full source code and output</h3>

<p>The rest of the implementation doesn&rsquo;t advance beyond these concepts, so I&rsquo;ll simply provide it without further comment. I hope this post highlighted some of the possibilities of PureScript&rsquo;s very flexible FFI in general, and specifically the C++ backend&rsquo;s flavor of it.</p>

<figure class='code'><figcaption><span> Main.purs</span> <a href='http://andyarvanitis.com/downloads/code/Main.purs'>download</a></figcaption>
<div class="highlight"><pre class="code"><code class = "#{lang}"><span class="kr">module</span> <span class="nn">Main</span> <span class="kr">where</span>

<span class="kr">import</span> <span class="nn">Prelude</span>
<span class="kr">import</span> <span class="nn">Control.Monad.Eff</span> <span class="p">(</span><span class="kt">Eff</span><span class="p">)</span>
<span class="kr">import</span> <span class="nn">Control.Monad.Eff.Console</span> <span class="p">(</span><span class="kt">CONSOLE</span><span class="p">,</span> <span class="nf">log</span><span class="p">,</span> <span class="nf">logShow</span><span class="p">)</span>
<span class="kr">import</span> <span class="nn">Data.Either</span> <span class="p">(</span><span class="kt">Either</span><span class="p">(</span><span class="o">..</span><span class="p">))</span>
<span class="kr">import</span> <span class="nn">Data.Tuple</span> <span class="p">(</span><span class="kt">Tuple</span><span class="p">)</span>

<span class="nf">foreign</span> <span class="kr">import</span> <span class="nn">data</span> <span class="kt">PCREOption</span> <span class="ow">::</span> <span class="o">*</span>
<span class="nf">foreign</span> <span class="kr">import</span> <span class="nn">data</span> <span class="kt">PCRECode</span> <span class="ow">::</span> <span class="o">*</span>

<span class="nf">foreign</span> <span class="kr">import</span> <span class="nn">caseless</span> <span class="ow">::</span> <span class="kt">PCREOption</span>
<span class="nf">foreign</span> <span class="kr">import</span> <span class="nn">dotall</span>   <span class="ow">::</span> <span class="kt">PCREOption</span>

<span class="nf">foreign</span> <span class="kr">import</span> <span class="nn">compile</span> <span class="ow">::</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">Array</span> <span class="kt">PCREOption</span> <span class="ow">-&gt;</span> <span class="kt">Either</span> <span class="kt">String</span> <span class="kt">PCRECode</span>

<span class="nf">foreign</span> <span class="kr">import</span> <span class="nn">capturedCount</span> <span class="ow">::</span> <span class="kt">PCRECode</span> <span class="ow">-&gt;</span> <span class="kt">Int</span>

<span class="nf">foreign</span> <span class="kr">import</span> <span class="nn">exec</span> <span class="ow">::</span> <span class="kt">PCRECode</span> <span class="ow">-&gt;</span>
                       <span class="kt">String</span> <span class="ow">-&gt;</span>
                       <span class="kt">Int</span> <span class="ow">-&gt;</span>
                       <span class="kt">Array</span> <span class="kt">PCREOption</span> <span class="ow">-&gt;</span>
                       <span class="kt">Int</span> <span class="ow">-&gt;</span>
                       <span class="kt">Either</span> <span class="kt">Int</span> <span class="p">(</span><span class="kt">Array</span> <span class="p">(</span><span class="kt">Tuple</span> <span class="kt">Int</span> <span class="kt">Int</span><span class="p">))</span>

<span class="nf">main</span> <span class="ow">::</span> <span class="n">forall</span> <span class="n">e</span><span class="o">.</span> <span class="kt">Eff</span> <span class="p">(</span> <span class="n">console</span> <span class="ow">::</span> <span class="kt">CONSOLE</span> <span class="o">|</span> <span class="n">e</span> <span class="p">)</span> <span class="kt">Unit</span>
<span class="nf">main</span> <span class="ow">=</span> <span class="kr">do</span>
  <span class="kr">case</span> <span class="p">(</span><span class="n">compile</span> <span class="s">&quot;^([^!]+)!(.+)=apquxz</span><span class="se">\\</span><span class="s">.ixr</span><span class="se">\\</span><span class="s">.zzz</span><span class="se">\\</span><span class="s">.ac</span><span class="se">\\</span><span class="s">.uk$&quot;</span> <span class="p">[</span><span class="n">caseless</span><span class="p">])</span> <span class="kr">of</span>
    <span class="kt">Left</span> <span class="n">err</span> <span class="ow">-&gt;</span> <span class="n">log</span> <span class="n">err</span>
    <span class="kt">Right</span> <span class="n">pcre</span> <span class="ow">-&gt;</span> <span class="kr">do</span>
      <span class="kr">let</span> <span class="n">sz</span> <span class="ow">=</span> <span class="p">(</span><span class="n">capturedCount</span> <span class="n">pcre</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mi">3</span>
          <span class="n">result</span> <span class="ow">=</span> <span class="n">exec</span> <span class="n">pcre</span> <span class="s">&quot;abc!pqr=apquxz.ixr.zzz.ac.uk&quot;</span> <span class="mi">0</span> <span class="kt">[]</span> <span class="n">sz</span>
      <span class="n">logShow</span> <span class="n">result</span>
</code></pre></div></figure>




<figure class='code'><figcaption><span> Main.hh</span> <a href='http://andyarvanitis.com/downloads/code/Main.hh'>download</a></figcaption>
<div class="highlight"><pre class="code"><code class = "#{lang}"><span class="cp">#ifndef MainFFI_HH</span>
<span class="cp">#define MainFFI_HH</span>

<span class="cp">#include &lt;pcre.h&gt;</span>
<span class="cp">#include &quot;PureScript/PureScript.hh&quot;</span>

<span class="k">namespace</span> <span class="n">Main</span> <span class="p">{</span>

  <span class="k">using</span> <span class="k">namespace</span> <span class="n">PureScript</span><span class="p">;</span>

  <span class="k">enum</span> <span class="p">{</span>
    <span class="n">caseless</span> <span class="o">=</span> <span class="n">PCRE_CASELESS</span><span class="p">,</span>
    <span class="n">dotall</span>   <span class="o">=</span> <span class="n">PCRE_DOTALL</span>
  <span class="p">};</span>

  <span class="k">auto</span> <span class="n">compile</span><span class="p">(</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">pattern</span><span class="p">,</span> <span class="k">const</span> <span class="n">any</span><span class="o">::</span><span class="n">array</span><span class="o">&amp;</span> <span class="n">options</span> <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">any</span><span class="p">;</span>

  <span class="k">auto</span> <span class="n">capturedCount</span><span class="p">(</span> <span class="k">const</span> <span class="n">any</span><span class="o">&amp;</span> <span class="n">code</span> <span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">int</span><span class="p">;</span>

  <span class="k">auto</span> <span class="n">exec</span><span class="p">(</span> <span class="k">const</span> <span class="n">any</span><span class="o">&amp;</span> <span class="n">code</span><span class="p">,</span>
             <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">subject</span><span class="p">,</span>
             <span class="kt">int</span> <span class="n">startoffset</span><span class="p">,</span>
             <span class="k">const</span> <span class="n">any</span><span class="o">::</span><span class="n">array</span><span class="o">&amp;</span> <span class="n">options</span><span class="p">,</span>
             <span class="kt">int</span> <span class="n">ovecsize</span> <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">any</span><span class="p">;</span>

<span class="p">}</span> <span class="c1">// namespace Main</span>

<span class="cp">#endif </span><span class="c1">// MainFFI_HH</span>
</code></pre></div></figure>




<figure class='code'><figcaption><span> Main.cc</span> <a href='http://andyarvanitis.com/downloads/code/Main.cc'>download</a></figcaption>
<div class="highlight"><pre class="code"><code class = "#{lang}"><span class="cp">#include &lt;cstring&gt;</span>
<span class="cp">#include &quot;Main.hh&quot;</span>

<span class="k">namespace</span> <span class="n">Main</span> <span class="p">{</span>

  <span class="k">static</span> <span class="k">auto</span> <span class="n">bitor_all</span><span class="p">(</span> <span class="k">const</span> <span class="n">any</span><span class="o">::</span><span class="n">array</span><span class="o">&amp;</span> <span class="n">opts</span> <span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">combined_opts</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">it</span> <span class="o">=</span> <span class="n">opts</span><span class="p">.</span><span class="n">cbegin</span><span class="p">(),</span> <span class="n">end</span> <span class="o">=</span> <span class="n">opts</span><span class="p">.</span><span class="n">cend</span><span class="p">();</span> <span class="n">it</span> <span class="o">!=</span> <span class="n">end</span><span class="p">;</span> <span class="n">it</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">combined_opts</span> <span class="o">|=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="o">*</span><span class="n">it</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">combined_opts</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">auto</span> <span class="n">compile</span><span class="p">(</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">pattern</span><span class="p">,</span> <span class="k">const</span> <span class="n">any</span><span class="o">::</span><span class="n">array</span><span class="o">&amp;</span> <span class="n">options</span> <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">any</span> <span class="p">{</span>
    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">err</span> <span class="o">=</span> <span class="n">nullptr</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">erroffset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">auto</span> <span class="n">ptr</span> <span class="o">=</span> <span class="n">pcre_compile</span><span class="p">(</span><span class="n">pattern</span><span class="p">,</span>
                            <span class="n">bitor_all</span><span class="p">(</span><span class="n">options</span><span class="p">),</span>
                            <span class="o">&amp;</span><span class="n">err</span><span class="p">,</span>
                            <span class="o">&amp;</span><span class="n">erroffset</span><span class="p">,</span>
                            <span class="n">nullptr</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">ptr</span> <span class="o">?</span> <span class="n">Right</span><span class="p">(</span><span class="n">managed</span><span class="o">&lt;</span><span class="n">pcre</span><span class="o">&gt;</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="n">pcre_free</span><span class="p">))</span> <span class="o">:</span> <span class="n">Left</span><span class="p">(</span><span class="n">err</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="k">auto</span> <span class="n">capturedCount</span><span class="p">(</span> <span class="k">const</span> <span class="n">any</span><span class="o">&amp;</span> <span class="n">code</span> <span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">pcre_fullinfo</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cast</span><span class="o">&lt;</span><span class="n">pcre</span><span class="o">&gt;</span><span class="p">(</span><span class="n">code</span><span class="p">),</span>
                  <span class="n">nullptr</span><span class="p">,</span>
                  <span class="n">PCRE_INFO_CAPTURECOUNT</span><span class="p">,</span>
                  <span class="o">&amp;</span><span class="n">count</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">count</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">auto</span> <span class="n">exec</span><span class="p">(</span> <span class="k">const</span> <span class="n">any</span><span class="o">&amp;</span> <span class="n">code</span><span class="p">,</span>
             <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">subject</span><span class="p">,</span>
             <span class="kt">int</span> <span class="n">startoffset</span><span class="p">,</span>
             <span class="k">const</span> <span class="n">any</span><span class="o">::</span><span class="n">array</span><span class="o">&amp;</span> <span class="n">options</span><span class="p">,</span>
             <span class="kt">int</span> <span class="n">ovecsize</span> <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">any</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">ovector</span><span class="p">[</span><span class="n">ovecsize</span><span class="p">];</span>
    <span class="k">auto</span> <span class="n">r</span> <span class="o">=</span> <span class="n">pcre_exec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cast</span><span class="o">&lt;</span><span class="n">pcre</span><span class="o">&gt;</span><span class="p">(</span><span class="n">code</span><span class="p">),</span>
                       <span class="n">nullptr</span><span class="p">,</span>
                       <span class="n">subject</span><span class="p">,</span>
                       <span class="n">strlen</span><span class="p">(</span><span class="n">subject</span><span class="p">),</span>
                       <span class="n">startoffset</span><span class="p">,</span>
                       <span class="n">bitor_all</span><span class="p">(</span><span class="n">options</span><span class="p">),</span>
                       <span class="n">ovector</span><span class="p">,</span>
                       <span class="n">ovecsize</span><span class="p">);</span>
    <span class="n">any</span><span class="o">::</span><span class="n">array</span> <span class="n">offsets</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">r</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">offsets</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span> <span class="n">Tuple</span><span class="p">(</span><span class="n">ovector</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">ovector</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span> <span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">r</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">?</span> <span class="n">Left</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="o">:</span> <span class="n">Right</span><span class="p">(</span><span class="n">offsets</span><span class="p">);</span>
  <span class="p">}</span>

<span class="p">}</span> <span class="c1">// Main</span>
</code></pre></div></figure>


<p><strong>Build and run</strong></p>

<figure class='code'><div class="highlight"><pre class="code"><code class = "#{lang}">$ make debug -j4 LDFLAGS=-lpcre
...
$ make run
(Right [(Tuple 0 28),(Tuple 0 3),(Tuple 4 7)])
</code></pre></div></figure>


<p><a name="footnote"></a></br></p>

<ol style="font-size:80%">
<li>It&#8217;s also possible to go with “effectful” functions, and handle allocation and mutation in ways similar to what is done in the book, or with something like PureScript&#8217;s <code>STRef</code>, or something else altogether.</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS (and macOS) with PureScript C++]]></title>
    <link href="http://andyarvanitis.com/ios-with-purescript-c-plus-plus/"/>
    <updated>2016-11-30T09:34:00-08:00</updated>
    <id>http://andyarvanitis.com/ios-with-purescript-c-plus-plus</id>
    <content type="html"><![CDATA[<p>Thanks to Xcode&rsquo;s support for custom script build phases and environment variables compatible with GNU Make, you can integrate your PureScript code fairly painlessly. In this post I&rsquo;ll show you the basics of using PureScript in an Xcode project. I&rsquo;m just going to focus on that, so you won&rsquo;t get any details on things like the (bidirectional) FFI here &mdash; I plan to cover that in another post.</p>

<p>To keep things simple, in this post I&rsquo;ll assume:</p>

<ul>
<li>You&rsquo;re running macOS El Capitan (10.11) or later</li>
<li>You&rsquo;re already familiar with PureScript, and have a recent version installed</li>
<li>You have a recent version of Xcode (7.3+) installed</li>
<li>You&rsquo;re familiar with the basics of iOS/macOS development using Xcode</li>
</ul>


<p>These instructions should apply to all Xcode-based targets, although I&rsquo;ve only tested iOS and macOS for now.</p>

<p><strong>Step 1: Install the PureScript-to-C++11 compiler,</strong> <code>pcc</code></p>

<ol>
<li>Go to the <a href="https://github.com/pure11/pure11/releases">pure11 repo releases</a> and download the latest <code>pcc.zip</code> file. If you already have a version installed, be sure to use a version dated <strong>2016-11-22</strong> or later, since that&rsquo;s when extra support for Xcode was added.</li>
<li>Unzip and copy to the same directory you installed other PureScript utilities (particulary <code>psc-package</code>). This restriction might be removed later.</li>
</ol>


<p><strong>Step 2: Create a new Xcode iOS project in the standard way</strong></p>

<ol>
<li><p>Using Xcode&rsquo;s menus:</p>

<p> File &ndash;><br/>
 New &ndash;><br/>
 Project&hellip;&ndash;><br/>
 iOS &ndash;><br/>
 Single View Application &ndash;><br/>
 Language: Objective-C (for now, we&rsquo;ll do Swift in a later post)</p></li>
<li><p>Save the project anywhere you like</p></li>
<li>Make sure to do your normal selection of Team, Provisioning Profile, etc. If you aren&rsquo;t a registered developer and only plan to try this on the simulator, I believe you won&rsquo;t need them.</li>
</ol>


<p><strong>Step 3: Create some PureScript code to use in your project</strong></p>

<ol>
<li><p>Create a directory anywhere you like. We&rsquo;ll refer to it as your PureScript working directory. In that directory, create a subdirectory called &ldquo;<code>src</code>&rdquo;.</p></li>
<li><p>In <code>src</code>, create a PureScript source file, naming it &ldquo;<code>PMath.purs</code>&rdquo;. Add the following code to <code>PMath.purs</code>:</p></li>
</ol>


<ul style="position: relative; top: -2em; margin-bottom: -2em">

<figure class='code'><div class="highlight"><pre class="code"><code class = "#{lang}"><span class="kr">module</span> <span class="nn">PMath</span> <span class="kr">where</span>

<span class="kr">import</span> <span class="nn">Prelude</span>

<span class="nf">fib</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Int</span>
<span class="nf">fib</span> <span class="mi">0</span> <span class="ow">=</span> <span class="mi">0</span>
<span class="nf">fib</span> <span class="mi">1</span> <span class="ow">=</span> <span class="mi">1</span>
<span class="nf">fib</span> <span class="n">n</span> <span class="ow">=</span> <span class="n">fib</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">fib</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
</code></pre></div></figure>

</ul>




<ol start="3">
<li>
In the Terminal, from your working directory (one level up from <code>src</code>), run the <code>pcc</code> command with just the <code>--xcode</code> option:

<span style="position: relative; top: 1em;">


<figure class='code'><div class="highlight"><pre class="code"><code class = "#{lang}">~/Projects/BlogPureScript/$ pcc --xcode

Generating psc-xcode.sh...
Done
Add this file to an Xcode &#39;Run Script&#39; build phase.

Generating psc-package.json...
Done
Use the &#39;psc-package&#39; utility to install or update packages.

Generating Makefile... pcc executable location /Users/andy/.local/bin/pcc
Done

Run &#39;make&#39; or &#39;make release&#39; to build an optimized release build.
Run &#39;make debug&#39; to build an executable with assertions enabled and
suitable for source-level debugging.

The resulting binary executable will be located in output/bin (by default).

~/Projects/BlogPureScript/$
</code></pre></div></figure>


</span>
</li>
</ol>


<p><strong>Step 4: Add PureScript code to your project settings</strong></p>

<ol>
<li><p>From Xcode&rsquo;s &ldquo;Project navigator,&rdquo; select your project (topmost level). You should see various tabs in the main window. Select &ldquo;Build Phases&rdquo; and:</p>

<ol type="a">
<li>Click the &ldquo;+&rdquo; &ndash;> &ldquo;New Run Script Phase&rdquo;</li>
<li>Drag the new &ldquo;Run Script&rdquo; section to be <em>before</em> &ldquo;Compile Sources&rdquo;</li>
<li><p>Expand the &ldquo;Run Script&rdquo; section (triangle), and in its editor add the following:</p>

<pre><code> cd path/to/your/working_dir
 sh psc-xcode.sh
</code></pre></li>
</ol>


<p>   It should look similar to this screenshot:</p>

<p>   <img src="http://andyarvanitis.com/images/run_script.png"></p></li>
<li><p>Now go to the &ldquo;Build Settings&rdquo; tab. Using the embedded search control (upper right), enter &ldquo;header search&rdquo;. If you don&rsquo;t see any results, make sure you have the &ldquo;All&rdquo; button selected (instead of &ldquo;Basic&rdquo; or &ldquo;Customized&rdquo;). Select the &ldquo;Header Search Paths&rdquo; item and add the value &ldquo;<code>path/to/your/working_dir/output</code>&rdquo; to it, meaning the &ldquo;<code>output</code>&rdquo; subdirectory in your working directory (it doesn&rsquo;t exist yet, but it will be generated during the build process). Make sure to press &ldquo;return&rdquo; to save the value.</p>

<p>   <img src="http://andyarvanitis.com/images/search_paths.png"></p></li>
<li><p>Again from &ldquo;Build Settings,&rdquo; change your search term to &ldquo;linker flags&rdquo; to find &ldquo;Other Linker Flags.&rdquo; Add the values<br>&ldquo;<code>-lc++ path/to/your/working_dir/output/bin/purescript.o</code>&rdquo;, as shown below. This &ldquo;<code>.o</code>&rdquo; file is a native combined object file containing all of your compiled PureScript modules (sort of like a static lib), which will be generated during the build process. Again, remember to press &ldquo;return&rdquo;.</p>

<p>   <img src="http://andyarvanitis.com/images/linker_flags.png"></p></li>
</ol>


<p><strong>Step 5: Add some Objective-C++ code that calls your PureScript code</strong></p>

<ol>
<li><p>In your Xcode project, rename <code>ViewController.m</code> to <code>ViewController.mm</code> &mdash; make sure you do this from Xcode, not the Terminal.</p></li>
<li><p>In <code>ViewController.mm</code> you should see implementations for methods like <code>viewDidLoad</code>. Add the implementation for <code>viewDidAppear</code> shown below, as well as adding <code>#import "PMath/PMath.hh"</code> and <code>using PMath::fib;</code> near the top. Ignore any of the &ldquo;live&rdquo; errors for now.</p></li>
</ol>


<ul style="position: relative; top: -2em;">


<figure class='code'><div class="highlight"><pre class="code"><code class = "#{lang}"><span class="cp">#import &quot;ViewController.h&quot;</span>
<span class="cp">#import &quot;PMath/PMath.hh&quot;</span>

<span class="c1">// This isn&#39;t necessary if we qualify our calls to the</span>
<span class="c1">// function as PMath::fib(x) -- but it looks nicer...</span>
<span class="c1">//</span>
<span class="n">using</span> <span class="n">PMath</span><span class="o">::</span><span class="n">fib</span><span class="p">;</span>

<span class="k">@interface</span> <span class="nc">ViewController</span> <span class="p">()</span>
<span class="k">@end</span>

<span class="k">@implementation</span> <span class="nc">ViewController</span>

<span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">viewDidLoad</span> <span class="p">{</span>
  <span class="p">[</span><span class="n">super</span> <span class="n">viewDidLoad</span><span class="p">];</span>
<span class="p">}</span>

<span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">viewDidAppear:</span><span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span> <span class="n">animated</span> <span class="p">{</span>
  <span class="p">[</span><span class="n">super</span> <span class="nl">viewDidAppear:</span><span class="n">animated</span><span class="p">];</span>

  <span class="c1">// Direct call to our PureScript function</span>
  <span class="c1">//</span>
  <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">fib</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>

  <span class="n">NSString</span><span class="o">*</span> <span class="n">resultString</span> <span class="o">=</span>
    <span class="p">[</span><span class="n">NSString</span> <span class="nl">stringWithFormat:</span><span class="s">@&quot;Result of fib 10 is %d&quot;</span><span class="p">,</span> <span class="n">result</span><span class="p">];</span>

  <span class="n">UIAlertController</span> <span class="o">*</span> <span class="n">alert</span> <span class="o">=</span>
    <span class="p">[</span><span class="n">UIAlertController</span> <span class="nl">alertControllerWithTitle:</span><span class="s">@&quot;Value from PureScript&quot;</span>
                                        <span class="nl">message:</span><span class="n">resultString</span>
                                 <span class="nl">preferredStyle:</span><span class="n">UIAlertControllerStyleAlert</span><span class="p">];</span>
  <span class="kt">id</span> <span class="n">okAction</span> <span class="o">=</span>
    <span class="p">[</span><span class="n">UIAlertAction</span> <span class="nl">actionWithTitle:</span><span class="s">@&quot;OK&quot;</span>
                             <span class="nl">style:</span><span class="n">UIAlertActionStyleDefault</span>
                           <span class="nl">handler:</span><span class="o">^</span><span class="p">(</span><span class="n">UIAlertAction</span> <span class="o">*</span> <span class="n">_Nonnull</span> <span class="n">action</span><span class="p">)</span> <span class="p">{</span>
                           <span class="p">}];</span>

  <span class="p">[</span><span class="n">alert</span> <span class="nl">addAction:</span><span class="n">okAction</span><span class="p">];</span>
  <span class="p">[</span><span class="n">self</span> <span class="nl">presentViewController:</span><span class="n">alert</span> <span class="nl">animated:</span><span class="n">YES</span> <span class="nl">completion:</span><span class="nb">nil</span><span class="p">];</span>
<span class="p">}</span>

<span class="k">@end</span>
</code></pre></div></figure>

</ul>


<p><strong>Step 6: Build the project and run it</strong></p>

<ol>
<li><p>For now, make sure your project is set to build a simulator target (it should be, by default). Build using Xcode&rsquo;s usual menu, Product &ndash;> Build (or shortcut Command-B). You should get a &ldquo;build succeeded&rdquo;.</p></li>
<li><p>Run it! (menu Product &ndash;> Run or shortcut Command-R)</p>

<p>   <img src="http://andyarvanitis.com/images/ios_app.png" width="375"></p></li>
<li><p>With Debug builds, you can use Xcode&rsquo;s debugger as well (on the generated C++ code):</p>

<p>   <img src="http://andyarvanitis.com/images/debugger.png"></p></li>
</ol>


<p><strong>Next steps</strong></p>

<p>You can now proceed to make changes to any source files (including your PureScript ones) and simply rebuild/test/repeat using Xcode. As you&rsquo;re developing your app, if you just want to type check your PureScript changes (not recompile all the way to a binary target), use Terminal to run &ldquo;<code>make codegen</code>&rdquo; from your working directory.</p>

<p>If you take a peek at the <code>psc-xcode.sh</code> script, you&rsquo;ll see that your compiled PureScript C++ objects will respect your project settings for things like Debug/Release builds and target architecture &mdash; and will rebuild appropriately if any of these things change. This also means you can do device hardware builds; as with any normal iOS project, simply change your target to one of the device variants and build.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[“Hello, world” with PureScript C++]]></title>
    <link href="http://andyarvanitis.com/hello-world-purescript-cpp/"/>
    <updated>2016-11-16T13:36:00-08:00</updated>
    <id>http://andyarvanitis.com/hello-world-purescript-cpp</id>
    <content type="html"><![CDATA[<p>This is a short-as-possible demonstration of using <a href="https://github.com/pure11/pure11">PureScript&rsquo;s C++11 backend</a> (a.k.a. pure11) to build a native command-line application.</p>

<p>To keep things simple, in this post I&rsquo;ll assume:</p>

<ul>
<li>You&rsquo;re running macOS El Capitan (10.11) or later</li>
<li>You&rsquo;re already familiar with PureScript, and have a recent version installed</li>
<li>You have either a recent version of Xcode (7.3+) or its command-line tools installed (<code>git</code>, <code>clang</code>, and <code>make</code> need to be there)</li>
</ul>


<p>I&rsquo;ll go through the steps, and then provide a few extra details afterwards.</p>

<p><strong>Step 1: Install the PureScript-to-C++11 compiler,</strong> <code>pcc</code></p>

<ol>
<li>Go to the <a href="https://github.com/pure11/pure11/releases">pure11 repo releases</a> and download the latest <code>pcc.zip</code> file</li>
<li>Unzip and copy to a location on your path</li>
</ol>


<p><strong>Step 2: Write your “hello, world” program</strong></p>

<ol>
<li>Make a working directory anywhere you like, named anything you like</li>
<li>Make a subdirectory there called “<code>src</code>”</li>
<li>Create your source file in <code>src</code> with contents:</li>
</ol>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><pre class="code"><code class = "#{lang}"><span class="kr">module</span> <span class="nn">Main</span> <span class="kr">where</span>

<span class="kr">import</span> <span class="nn">Prelude</span>
<span class="kr">import</span> <span class="nn">Control.Monad.Eff</span> <span class="p">(</span><span class="kt">Eff</span><span class="p">)</span>
<span class="kr">import</span> <span class="nn">Control.Monad.Eff.Console</span> <span class="p">(</span><span class="kt">CONSOLE</span><span class="p">,</span> <span class="nf">log</span><span class="p">)</span>

<span class="nf">main</span> <span class="ow">::</span> <span class="kt">Eff</span> <span class="p">(</span><span class="n">console</span> <span class="ow">::</span> <span class="kt">CONSOLE</span><span class="p">)</span> <span class="kt">Unit</span>
<span class="nf">main</span> <span class="ow">=</span> <span class="kr">do</span>
<span class="nf">log</span> <span class="s">&quot;hello, world!&quot;</span>
</code></pre></div></figure>


<p><strong>Step 3: Generate configuration files (</strong><code>Makefile</code> <strong>and</strong> <code>psc-package.json</code><strong>)</strong></p>

<p>From your working directory run the <code>pcc</code> command with no arguments:</p>

<pre><code>$ pcc
</code></pre>

<p>You should see something like:</p>

<pre><code>Generating Makefile... pcc executable location /Users/andy/.local/bin/pcc
Done

Run 'make' or 'make release' to build an optimized release build.
Run 'make debug' to build an executable with assertions enabled and
suitable for source-level debugging.

The resulting binary executable will be located in output/bin (by default).
</code></pre>

<p><strong>Step 4: Build and run</strong></p>

<ol>
<li><p>Again from your working directory, run the <code>make</code> command:</p>

<pre><code> $ make
</code></pre>

<p> You should see something like:</p>

<pre><code> Getting packages using 'psc-package'...
 Updating 3 packages...
 Updating console
 Updating eff
 Updating prelude
 Update complete
 ...
 Compiling Data.NaturalTransformation
 Compiling Data.Show
 Compiling Data.Boolean
 Compiling Control.Semigroupoid
 Compiling Control.Category
 Compiling Data.Void
 Compiling Data.Unit
 ...
 Compiling Main
 Creating output/Control/Applicative/Applicative.o
 Creating output/Control/Apply/Apply.o
 Creating output/Control/Apply/Apply_ffi.o
 Creating output/Control/Bind/Bind.o
 ...
 Linking output/bin/main
</code></pre></li>
<li><p>Run your new program:</p>

<pre><code>$ ./output/bin/main 
hello, world!
</code></pre></li>
</ol>


<p>And that&rsquo;s it!</p>

<p><strong>Next steps</strong></p>

<p>As you make any changes to your source (<code>.purs</code>) file(s), simply run <code>make</code> again to rebuild.</p>

<p>Using PureScript&rsquo;s new <code>psc-package</code> utility, you can install more packages (libraries of modules) from a verified package set.</p>

<p>This is by no means the only thing you can do with the tools, nor is it the only plaform supported &mdash; I regularly test on Linux (gcc) and occasionally Windows 10 (Visual Studio 2015) &mdash; but it should give you the basics of getting up and running.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Using Idris with Objective-C]]></title>
    <link href="http://andyarvanitis.com/using-idris-with-objective-c/"/>
    <updated>2014-02-23T15:00:00-08:00</updated>
    <id>http://andyarvanitis.com/using-idris-with-objective-c</id>
    <content type="html"><![CDATA[<p>I&rsquo;ve recently been playing around with <a href="http://www.idris-lang.org/">Idris</a>, a functional language in
the <a href="http://www.haskell.org/haskellwiki/Haskell">Haskell</a> family. I won&rsquo;t get into its design or features
here, but I&rsquo;ll simply state that, unlike Haskell, it has dependent types and is evaluated eagerly
(not lazily) by default. It offers a simple FFI to C, so I was curious what integration with Objective-C
would look like. I haven&rsquo;t found any examples of that, so I thought I&rsquo;d give it a try and share
my results.</p>

<p>One note: although Idris offers an LLVM backend, I only used the default C backend for this exercise.</p>

<p>My general strategy was to use the Objective-C runtime functions via the FFI, and to define Idris
types to keep the operations as type-safe as possible.</p>

<h2>Basics</h2>

<p>I started with just the basics &mdash; getting access to Objective-C classes and selectors:</p>

<!--?prettify lang=hs?-->


<pre><code>module objective_c

%include C "objc/runtime.h"
%include C "objc_stubs.h"

-------------------------------------------------------------------------------
class Object a where
   getPtr : a -&gt; IO Ptr

-------------------------------------------------------------------------------
getClass : String -&gt; IO Ptr
-------------------------------------------------------------------------------
getClass name = mkForeign (FFun "objc_getClass" [FString] FPtr) name

-------------------------------------------------------------------------------
getSelector : String -&gt; IO Ptr
-------------------------------------------------------------------------------
getSelector selname = mkForeign (FFun "sel_registerName" [FString] FPtr) selname 
</code></pre>

<p>This is a module defining an <code>Object</code> typeclass and two functions: one for getting classes and one for
getting selectors from the runtime. Idris&#8217; FFI defines a <code>Ptr</code> type, which represents, as you would expect,
a general (<code>void *</code>) C pointer. Every Objective-C object type in this exercise is an instance of
the <code>Object</code> typeclass, including classes themselves (more later), and function <code>getPtr</code> is used to
retrieve the underlying foreign pointer when needed. Like function/method calls to Objective-C, and
C function calls in general, the retrieval of the pointer is IO monadic.</p>

<p>Also note the <code>%include</code> statements, which directly parse C headers. I ran into some problems
with the type signatures of a couple of functions, so I created stubs. The stub prototype used in
this example module is:</p>

<pre><code>extern void* objc_msgSend(void* self, void* op, ...);
</code></pre>

<p>It should be possible to get rid of at least some of these stubs.</p>

<h2>Objective-C classes</h2>

<p>Next up is an example of a specific Objective-C class. I started off with <code>NSObject</code>, putting it in its own
module:</p>

<!--?prettify lang=hs?-->


<pre><code>module NSObject

import objective_c

-------------------------------------------------------------------------------
data NSObject'Class = Metaclass

instance Object NSObject'Class where
   getPtr o = getClass "NSObject"

-------------------------------------------------------------------------------
metaclass : IO NSObject'Class
-------------------------------------------------------------------------------
metaclass = return Metaclass

-------------------------------------------------------------------------------
record NSObject : Type where
   asObject : (pointer : Ptr) -&gt; NSObject

instance Object NSObject where
   getPtr o = return (pointer o)
</code></pre>

<p>The type <code>NSObject'Class</code> represents the type of the class itself &mdash; more precisely, in Objective-C terms, an instance of the object&rsquo;s metaclass. In other words, it&rsquo;s used to invoke class methods. To
get the metaclass instance, call the IO monadic <code>metaclass</code> function. Finally, type
<code>NSObject</code> represents an object, or instance of the objc class, used to invoke instance methods. You can
also see the for-internal-use implementations of <code>getPtr</code>.</p>

<p>I didn&rsquo;t bother to define any objc class or instance methods for <code>NSObject</code> here. Instead,
I&rsquo;ll pick a more interesting example: <code>NSString</code>.</p>

<h2>NSString</h2>

<p>I&rsquo;ve fleshed out a few methods for <code>NSString</code> below so you&rsquo;ll be able to see a workable and
hopefully slightly interesting &ldquo;hello, world&rdquo; (what else?) example.</p>

<p>You might notice that the object arguments for each function (method) appear last. This allows the
convenient use of Idris&#8217; bind operator, <code>&gt;&gt;=</code>, when calling them. You&rsquo;ll see examples of this
in the final code snippet. I got the idea from the
<a href="http://hoc.sourceforge.net/">HOC Haskell to Objective-C bindings</a>.</p>

<p>Idris provides a way to define functions for doing implicit type conversions. This is handy for safely using
our objc objects with superclass object functions (methods). Function <code>asNSObject</code> below
illustrates how we can do this.</p>

<p>Another thing to note is Idris&#8217; facility for named parameters/arguments, as seen in the definition
of function <code>stringByReplacingOccurrencesOfString</code> below. In the final code snippet, I&rsquo;ll show how it&rsquo;s used.</p>

<!--?prettify lang=hs?-->


<pre><code>module NSString

import objective_c
import NSObject 
import NSRange

-------------------------------------------------------------------------------
data NSString'Class = Metaclass

instance Object NSString'Class where
   getPtr o = getClass "NSString"

-------------------------------------------------------------------------------
metaclass : IO NSString'Class
-------------------------------------------------------------------------------
metaclass = return Metaclass

-------------------------------------------------------------------------------
record NSString : Type where
   asObject : (pointer : Ptr) -&gt; NSString

instance Object NSString where
   getPtr o = return (pointer o)

-------------------------------------------------------------------------------
implicit asNSObject : NSString -&gt; NSObject
-------------------------------------------------------------------------------
asNSObject o = NSObject.asObject (NSString.pointer o)

-------------------------------------------------------------------------------
implicit liftNSString : NSString -&gt; IO NSString
-------------------------------------------------------------------------------
liftNSString s = return s

-------------------------------------------------------------------------------
--------------------------- Class methods -------------------------------------
-------------------------------------------------------------------------------

-------------------------------------------------------------------------------
stringWithUTF8String : String -&gt; NSString'Class -&gt; IO NSString
-------------------------------------------------------------------------------
stringWithUTF8String s c = do 
   obj &lt;- getPtr c
   sel &lt;- getSelector "stringWithUTF8String:" 
   result &lt;- mkForeign (FFun "objc_msgSend" [FPtr, FPtr, FString] FPtr) 
                                             obj   sel   s
   return (asObject result)

-------------------------------------------------------------------------------
--------------------------- Instance methods ----------------------------------
-------------------------------------------------------------------------------

-------------------------------------------------------------------------------
length : NSString -&gt; IO Int
-------------------------------------------------------------------------------
length o = do 
   obj &lt;- getPtr o
   sel &lt;- getSelector "length" 
   mkForeign (FFun "objc_msgSend" [FPtr, FPtr] FInt) obj sel

-------------------------------------------------------------------------------
UTF8String : NSString -&gt; IO String
-------------------------------------------------------------------------------
UTF8String o = do 
   obj &lt;- getPtr o
   sel &lt;- getSelector "UTF8String" 
   mkForeign (FFun "objc_msgSend" [FPtr, FPtr] FString) obj sel

-------------------------------------------------------------------------------
stringByReplacingOccurrencesOfString : NSString -&gt; (withString : NSString) -&gt;
                                       NSString -&gt; 
                                       IO NSString
-------------------------------------------------------------------------------
stringByReplacingOccurrencesOfString s r o = do 
   obj &lt;- getPtr o
   sel &lt;- getSelector "stringByReplacingOccurrencesOfString:withString:"
   old &lt;- getPtr s
   new &lt;- getPtr r
   result &lt;- mkForeign (FFun "objc_msgSend" [FPtr, FPtr, FPtr, FPtr] FPtr) 
                                             obj   sel   old   new      
   return (asObject result)

-------------------------------------------------------------------------------
substringWithRange : NSRange -&gt; NSString -&gt; IO NSString
-------------------------------------------------------------------------------
substringWithRange (NSMakeRange loc len) o = do
   obj &lt;- getPtr o
   sel &lt;- getSelector "substringWithRange:"
   result &lt;- mkForeign (FFun "objc_msgSend" [FPtr, FPtr, FInt, FInt] FPtr) 
                                             obj   sel   loc   len      
   return (asObject result)
</code></pre>

<h2>Hello, world</h2>

<p>Putting it all together, we can now get a functioning Objective-C/Foundation example.</p>

<!--?prettify lang=hs?-->


<pre><code>module Main

import NSString
import NSFunctions

-------------------------------------------------------------------------------
%lib C "objc" 
%link C "/System/Library/Frameworks/Foundation.framework/Foundation" 
-------------------------------------------------------------------------------

-------------------------------------------------------------------------------
main : IO () 
-------------------------------------------------------------------------------
main = do

   recipient &lt;- NSString.metaclass &gt;&gt;= stringWithUTF8String "world" 
   separator &lt;- NSString.metaclass &gt;&gt;= stringWithUTF8String ", " 

   greeting &lt;- NSString.metaclass &gt;&gt;= 
                  stringWithUTF8String "hello" &gt;&gt;=
                     stringByAppendingString separator &gt;&gt;=
                        stringByAppendingString recipient

   format &lt;- NSString.metaclass &gt;&gt;= stringWithUTF8String "%@!"

   NSLog format greeting

   replacement &lt;- NSString.metaclass &gt;&gt;= stringWithUTF8String "everyone" 

   greeting &lt;- greeting &gt;&gt;= stringByReplacingOccurrencesOfString recipient {withString = replacement}

   NSLog format greeting

   substr &lt;- greeting &gt;&gt;= substringWithRange (NSMakeRange 7 5)

   substrLen &lt;- substr &gt;&gt;= length -- alternatively, "length substr"

   substring &lt;- substr &gt;&gt;= UTF8String -- alternatively, "UTF8String substr"

   -- 'substring' is now a regular Idris string, and 'substrLen' is an Int
   putStrLn $ "Substring: " ++ substring
   putStrLn $ "Length: " ++ show substrLen   

   return ()
</code></pre>

<p>The output:</p>

<pre><code>2014-02-23 14:50:37.209 hello[1622:507] hello, world!
2014-02-23 14:50:37.210 hello[1622:507] hello, everyone!
Substring: every
Length: 5
</code></pre>

<p>I intentionally use Idris&#8217; <code>&gt;&gt;=</code> bind in this code. I believe this works pretty well, overall.
You get something reminiscent of Objective-C message passing, you get nice chaining,
and you stick with idiomatic Idris monad conventions. Idris does allow some really cool
user-defined syntax extensions, so if you wanted, you could actually do something like this:</p>

<pre><code>term syntax "[" [o] [s1] ":" [arg1] [s2] ":" [arg2] "]" = (return o) &gt;&gt;= (s1 arg1 {s2 = arg2})

...

greeting &lt;- [greeting stringByReplacingOccurrencesOfString: recipient 
                                                withString: replacement]
</code></pre>

<p>This would effectively give you an EDSL for some very familiar-looking Objective-C code. As tempting
as something like this is, I would probably stay with an all- <code>&gt;&gt;=</code> approach.</p>

<h2>Final thoughts</h2>

<p>If you wanted to use standard Objective-C frameworks directly&mdash;i.e., not just a couple of adapter
classes&mdash;you probably wouldn&rsquo;t want to code the bindings by hand. You would want a utility to
parse the headers and generate something that looks like the <code>NSString</code> module example. This
shouldn&rsquo;t be too hard to do, actually. For example, given my experiences with
<a href="https://github.com/eerolanguage/eero/wiki/Translator">eero&rsquo;s source-to-source translator</a>,
clang&rsquo;s rewriting facilities could probably handle it well. There would also be some work
involved in getting things like memory management, returned structs, variadic functions, etc.
working seamlessly.</p>

<p>Also note that this is a contrived example. A good binding library would have more seamless
support for common conversions like native strings to/from Objective-C strings. And of course
you would want to do most of your string (or any other data) manipulations in Idris&#8217; pure
functional world and just get the results over to Objective-C. This was just a
convenient example.</p>

<p>You can find all of this sample code on <a href="https://github.com/andyarvanitis/IdrisObjCExperiment">github</a>.</p>

<p>Please feel free to
<a href="https://twitter.com/intent/tweet?text=@andyarvanitis%20RE:%20idris%2Dobjc%20">provide feedback via Twitter</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Safe Categories for Objective-C]]></title>
    <link href="http://andyarvanitis.com/objective-c-safe-categories/"/>
    <updated>2013-11-20T11:47:00-08:00</updated>
    <id>http://andyarvanitis.com/objective-c-safe-categories</id>
    <content type="html"><![CDATA[<p>My <a href="http://andyarvanitis.com/lazy-initialization-for-objective-c">previous blog post</a> introduced a technique for
<a href="http://en.wikipedia.org/wiki/Lazy_initialization">lazy initialization</a> in Objective-C.
Its main advantage is the simple way of using it: instead of sending <code>alloc</code> or <code>new</code> to a
class to create an instance, you send <code>lazy</code>, which could be added to <code>NSObject</code>
via a category.</p>

<p>There is, of course, a big problem with adding a “nice and clean” method to
a class with a category, especially <code>NSObject</code> — and that’s silent name collisions.
To make matters worse, you can&rsquo;t even predict which method you&rsquo;ll end up with when multiple versions
exist.
The solution, as we all know, is to <del>uglify</del> try to make the name unique, typically by adding
a prefix like &ldquo;axa_&rdquo;, yielding something like <code>axa_lazy</code>. Yuck.</p>

<p>It would be nice if we could have &ldquo;safe&rdquo; categories. Like just about everything else,
it&rsquo;s been discussed before (e.g., <a href="http://blog.securemacprogramming.com/2013/04/can-objective-c-be-given-safe-categories/">Graham Lee&rsquo;s recent blog post</a>), and there are some good implementations out there (e.g., <a href="https://github.com/jspahrsummers/libextobjc">jspahrsummers / libextobjc</a>). This is another shot at it. The goal is something
that is lightweight enough to avoid a library/framework (or lots of macros), and yet as safe as
possible &mdash; maybe even completely safe.</p>

<p>There&rsquo;s only so much we can do here at compile time, so the general strategy will be to use the
<a href="https://developer.apple.com/library/mac/documentation/cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008048">Objective-C runtime facilities</a> to extend classes, and use runtime assertions to catch/report conflicts.</p>

<p>Let&rsquo;s start with the interface. We can just use a standard category declaration (the same used in the previous blog post):</p>

<pre><code>@interface NSObject (AXALazyInitCategory)
+ (instancetype)lazy;
@end
</code></pre>

<p>For the implementation, our approach uses a subclass of the target class:</p>

<pre><code>#import &lt;objc/runtime.h&gt;
#import "Object+AXALazyInitialization.h"

@interface AXALazyInitCategory : NSObject // superclass is the category class
@end

static Class __targetClass;  // static, so private to this file
static Class __sourceClass;  //

@implementation AXALazyInitCategory

+ (void)load {
  __targetClass = [self superclass];
  __sourceClass = [self class];
  // do normal category-like +load stuff here, if desired...
}

+ (instancetype)lazy {
  // see previous blog post on lazy initialization...
}

@end
</code></pre>

<p>So we&rsquo;ve created a subclass of the desired category class, and during class load we saved off a static
reference to the target (in this case, <code>NSObject</code>) and source (implementations provider) classes.</p>

<p>Now, in the same source file, we define two functions. One runs on program startup, the other on
program termination:</p>

<pre><code>//-----------------------------------------------------------------------------
// Constructor code -- runs afer all +load calls are made
//-----------------------------------------------------------------------------
__attribute__((constructor)) static void pre_run_add_category_methods() {
  @autoreleasepool {
    const SEL selector = @selector(lazy);
    const Method method = class_getClassMethod(__sourceClass, selector);

    NSCAssert(!class_getClassMethod(__targetClass, selector),
              @"Safe category: redefined method '%@' found in class '%@'",
              NSStringFromSelector(selector), __targetClass);

    class_addMethod(object_getClass(__targetClass), selector,
                    method_getImplementation(method),
                    method_getTypeEncoding(method));
  }
}
//-----------------------------------------------------------------------------
// Destructor code -- runs during program termination
//-----------------------------------------------------------------------------
__attribute__((destructor)) static void post_run_check_category_methods() {
  @autoreleasepool {
    const SEL selector = @selector(lazy);
    const Method sourceMethod = class_getClassMethod(__sourceClass, selector);
    Method targetMethod = class_getClassMethod(__targetClass, selector);

    NSCAssert(method_getImplementation(targetMethod) == 
              method_getImplementation(sourceMethod),
              @"Safe category: redefined method '%@' found in class '%@'",
              NSStringFromSelector(selector), __targetClass);
  }
}
</code></pre>

<p>As noted, the function with the <code>constructor</code> attribute gets called after all <code>+load</code> methods have run.
Using <code>class_getClassMethod</code>, we first check to make sure this class &mdash; or any of its superclasses &mdash; doesn&rsquo;t already have an implementation of the method. If the test passes, we
add it to the class, just as real categories add methods to classes. An alternative approach
might be to simply check the result of the <code>class_addMethod</code> call. However, it only fails if the class
<em>itself</em> already had the method; otherwise, it overrides any version provided by a superclass. I want to be
extra-careful with my technique, so I have it fail if one exists up the chain.</p>

<p>The assertion will fail (causing the program to terminate with an error message) if our method
of interest was:</p>

<ol>
<li>defined in the class (or a superclass) to start with, or</li>
<li>added by any &ldquo;standard&rdquo; category (since they are loaded before this code is run), or</li>
<li>added by any other runtime technique that <em>just happened to run before this one</em>.</li>
</ol>


<p>Cases 1 and 2 are pretty solid, but of course we can&rsquo;t rely on 3. Thus we need to do another check
later, specifically in the function with the <code>destructor</code> attribute, which runs on program termination.
What happens here is we check the registered method implementation for the class again. If it&rsquo;s not
the one we added in this source file, we raise an error. This will catch any runtime method changes
that any source file or library might have done in our executable.</p>

<p>This is pretty good, but still not foolproof. I want to be extra-extra-careful (paranoid?). What if
someone sneaked in a version of the method not in the class itself, but a subclass?
Technically, it&rsquo;s a valid override, but I&rsquo;m adding a method that I want to ensure is a safe
extension to the standard frameworks, with no unknown conflicts. The same goes for the superclasses
up the inheritance chain &mdash; what if I don&rsquo;t want to accidentally override anything here?</p>

<p>The following code is intended to handle all these situations. While we&rsquo;re at it, we should have
a general way of adding and checking all of the methods in the &ldquo;implementation provider&rdquo; class,
rather than doing it manually.</p>

<pre><code>// File SafeCategories.h
#import &lt;Foundation/Foundation.h&gt;
#import &lt;objc/runtime.h&gt;

//---------------------------------------------------------------------------------------
// Pseudo function that must be called in "category" +load method. 
// The only public interface here.
//---------------------------------------------------------------------------------------
#define load_as_safe_category()        \
  __targetClass = [self superclass]; \
  __sourceClass = [self class];

//---------------------------------------------------------------------------------------
// Private static variable and function declarations
//---------------------------------------------------------------------------------------
static Class __targetClass = Nil;
static Class __sourceClass = Nil;

static NSString* const __RedefinedMethodFormattedErrorMessage =
    @"Safe category: redefined method '%@' found in class '%@'";

static NSArray* get_related_classes(Class baseClass);
static void process_methods(const Class sourceClass, const Class targetClass,
                            void (^method_operation)(Class, Method));

//---------------------------------------------------------------------------------------
// Constructor code -- runs afer all +load calls are made
//---------------------------------------------------------------------------------------
__attribute__((constructor)) static void pre_run_add_category_methods() {
  @autoreleasepool {
    process_methods(__sourceClass, __targetClass, ^(Class cls, Method method) {
      const SEL sel = method_getName(method);
      NSCAssert(!class_getInstanceMethod(cls, sel), // works with metaclasses too
                __RedefinedMethodFormattedErrorMessage,
                NSStringFromSelector(sel), cls);
      class_addMethod(cls, sel, method_getImplementation(method), method_getTypeEncoding(method));
    });
  }
}

#if !defined(NS_BLOCK_ASSERTIONS) // We don't need any of this if assertions are disabled

//---------------------------------------------------------------------------------------
// Destructor code -- runs during program termination
//---------------------------------------------------------------------------------------
__attribute__((destructor)) static void post_run_check_category_methods() {
  @autoreleasepool {
    for (Class relatedClass in get_related_classes(__targetClass)) {
      process_methods(__sourceClass, relatedClass, ^(Class cls, Method method) {
        const SEL selector = method_getName(method);
        unsigned int methodsCount = 0;
        Method* methods = class_copyMethodList(cls, &amp;methodsCount); // doesn't search superclasses
        for (unsigned int i = 0; i &lt; methodsCount; i++) {
          if (method_getName(methods[i]) == selector) {
            NSCAssert(method_getImplementation(methods[i]) == method_getImplementation(method),
                      __RedefinedMethodFormattedErrorMessage,
                      NSStringFromSelector(selector), cls);
            break;
          }
        }
        free(methods);
      });
    }
  }
}

//---------------------------------------------------------------------------------------
// Look through all of the classes registered with the runtime for super and subclasses.
//---------------------------------------------------------------------------------------
static NSArray* get_related_classes(Class baseClass) {
  NSMutableArray* relatedClasses = [NSMutableArray array];
  // First get the base and all its superclasses
  for (Class superClass = baseClass;
       superClass != Nil;
       superClass = class_getSuperclass(superClass)) {
    [relatedClasses addObject: superClass];
  }
  // Now get all subclasses of the base class
  unsigned int count = 0;
  Class* runtimeClasses = objc_copyClassList(&amp;count);
  for (unsigned int i = 0; i &lt; count; i++) {
    Class superClass = runtimeClasses[i];
    do {
      superClass = class_getSuperclass(superClass);
    } while (superClass &amp;&amp; superClass != baseClass);

    if (superClass != nil) {
      [relatedClasses addObject: runtimeClasses[i]];
    }
  }
  free(runtimeClasses);
  return relatedClasses;
}

#endif // !defined(NS_BLOCK_ASSERTIONS)

//---------------------------------------------------------------------------------------
static void process_methods(const Class sourceClass, const Class targetClass,
                            void (^method_operation)(Class, Method)) {
  void (^iterate_methods)(Class) = ^(Class cls) {
    const BOOL isMetaClass = class_isMetaClass(cls);
    unsigned int count = 0;
    Method* sourceMethods =
        class_copyMethodList(isMetaClass ? object_getClass(sourceClass) : sourceClass, &amp;count);
    for (unsigned int i = 0; i &lt; count; i++) {
      if (!isMetaClass || method_getName(sourceMethods[i]) != @selector(load)) {
        method_operation(cls, sourceMethods[i]);
      }
    }
    free(sourceMethods);
  };
  iterate_methods(object_getClass(targetClass));  // class methods
  iterate_methods(targetClass);                   // instance methods
}
</code></pre>

<p>And as an example of how it&rsquo;s actually used, here&rsquo;s the original example rewritten:</p>

<pre><code>#import "Object+AXALazyInitialization.h"
#import "SafeCategories.h"

@interface AXALazyInitCategory : NSObject // superclass is the category class
@end

@implementation AXALazyInitCategory

+ (void)load {
  load_as_safe_category();
}

+ (instancetype)lazy {
  // see previous blog post on lazy initialization...
}
@end
</code></pre>

<p>I feel this approach covers all the possible scenarios, but please feel free to <a href="https://twitter.com/intent/tweet?text=@andyarvanitis%20RE:%20safe%20categories%20">provide feedback via twitter</a> if you think I&rsquo;ve missed something.</p>

<p>In case you&rsquo;re wondering: yes, I am considering adding direct language support for something like this to
<a href="http://eerolanguage.org">eero</a> (though not quite yet).</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Lazy initialization for Objective-C]]></title>
    <link href="http://andyarvanitis.com/lazy-initialization-for-objective-c/"/>
    <updated>2013-09-22T14:47:00-07:00</updated>
    <id>http://andyarvanitis.com/lazy-initialization-for-objective-c</id>
    <content type="html"><![CDATA[<p><a href="http://en.wikipedia.org/wiki/Lazy_initialization">Lazy initialization</a> is a
technique for delaying a computationally or memory-intensive operation until
it&rsquo;s absolutely necessary. It&rsquo;s helpful for getting an object&rsquo;s expensive
creation or initialization out of the critical path, improving responsiveness or
memory use where it matters most.</p>

<p>It&rsquo;s a useful coding pattern. So useful, in fact, that some languages provide
direct support for it. Having used it many times in my career &mdash; and most
recently in some Android Java code &mdash; I&rsquo;ve thought about it in the context of
my <a href="http://eerolanguage.org/">Eero language project</a>. I wondered if I should
consider adding support for it in the Eero language itself (if not now, then
maybe in a future revision). But before I went that route, I thought I should
have a go at figuring out a clean way to do it in standard Objective-C (and Eero,
in its current form). My goal was to find a way to do it as unobtrusively as
possible. I wanted minimal impact to the class/object to which it would be
applied, making it akin to built-in language support, if at all possible. I&rsquo;d
settle for either a simple and clean pattern, or a small and non-fragile library.</p>

<p>This is what I came up with. It&rsquo;s probably been done before, in a similar, or
perhaps even the exact same way, by someone else. But not having spotted it
documented anywhere else, I thought I&rsquo;d share my results.</p>

<p>Note that, beyond what I&rsquo;ve already said, I won&rsquo;t provide a detailed argument
for lazy initialization&rsquo;s utility, or say much about how it shouldn’t be
overused (<em>it shouldn&rsquo;t be overused!</em>). I just want to document what I think is
a nice way to do it.</p>

<h2>What using it looks like</h2>

<p>I&rsquo;ll jump right to the final results here, at least from the perspective of the
user of the pattern/library.</p>

<p>Given a <em>type-safe</em> class method in a category has been defined on NSObject,
like so:</p>

<pre><code>@interface NSObject (LazyInitialization)
  + (instancetype)lazy;
@end
</code></pre>

<p>Class method <code>lazy</code> takes the place of both <code>alloc</code> and <code>new</code> when creating a
lazy instance. It can be chained with an <code>init</code> method or used on its own.</p>

<pre><code>SomeClass *object = [SomeClass lazy];

// ... do stuff
// ... sometime later...

[object doSomething]; // object will get initialized here, 
                      // and then perform 'doSomething'
</code></pre>

<p>That&rsquo;s it. No special checks before or within the first method call.
The lazy object can be of any class type. The method called can be a
regular instance method, or a property getter or setter. Any notation (e.g.,
property dot-notation) can be used. Either ARC or MRC is also fine.</p>

<p>As mentioned, class method <code>lazy</code> can be used standalone (acting like <code>new</code> when
the object goes active), chained with <code>init</code>, or chained with an <code>initWith</code> method.
The last case requires a bit of caution for pointers. Specifically, Objective-C
objects passed in get a <code>retain</code> and automatic <code>release</code>; C strings (any
<code>char*</code>, actually) get <em>copied</em> and freed automatically; and any other pointer
types are left alone. So for objects and C strings, there&rsquo;s nothing special you
need to do (although you’ll want to watch out for large string buffer copies).
But for pointers to any other type of data, you need to make sure the data stays
valid until the object fully initializes.</p>

<pre><code>NSMutableString *str = [NSMutableString new];
[str appendString:@"Hello"];
ClassX *obj1 = [[ClassX lazy] initWithString:str]; // str retained

ClassX *obj2 = [[ClassX lazy] initWithCString:"Hi"]; // char* copied

void *buf = ...
ClassX *obj3 = [[ClassX lazy] initWithBuffer:buf]; // nothing done
</code></pre>

<h2>How it all works</h2>

<p>Class method <code>lazy</code> returns an instance of a proxy object for the specified
class. The proxy then uses standard message forwarding to cache the <code>init</code>
invocation for later, and to create the real object instance at the appropriate
time and forward all subsequent messages. Memory management messages are not
forwarded, since they need to manage the lifetime of the proxy, which owns the
&ldquo;real&rdquo; object.</p>

<p>The base class of the proxy object is Foundation&rsquo;s <code>NSProxy</code>. As you would
imagine, it&rsquo;s designed for just this sort of purpose.</p>

<p>As for the forwarding mechanism, Foundation and the runtime provide two
different means: <code>forwardingTargetForSelector</code>, and <code>methodSignatureForSelector</code>
combined with <code>forwardInvocation</code>. Of the two, <code>forwardingTargetForSelector</code> is
faster. In the following code, the second, slower method(s) is only used to
cache the <code>init</code> method. Once the init happens, the faster method is used
exclusively and for the majority of the object&rsquo;s active life.</p>

<p>So here&rsquo;s the final code in Objective-C:</p>

<p><em>lazyinit.h</em></p>

<pre><code>#import &lt;Foundation/Foundation.h&gt;

@interface NSObject (LazyInitialization)
  + (instancetype)lazy;
@end
</code></pre>

<p><em>lazyinit.m</em></p>

<pre><code>#import &lt;Foundation/Foundation.h&gt;
#import "lazyinit.h"

#if !__has_feature(objc_arc)
   #error ARC must be enabled for this source file (but clients can use MRC).
#endif

@interface LazyProxy : NSProxy
- (instancetype)initWithClass:(Class)class;
@end

@implementation NSObject (LazyInitialization)
+ (instancetype)lazy {
  return (id)[LazyProxy.alloc initWithClass: [self class]];
}
@end

@implementation LazyProxy {
  id _object;
  Class _objectClass;
  NSInvocation *_initInvocation;
}

- (instancetype)initWithClass:(Class)cls {
  _objectClass = cls;
  return self;
}

- (void)instantiateObject {
  _object = [_objectClass alloc];
  if (_initInvocation == nil) {  // allow SomeClass.lazy (no explicit init)
    _object = [_object init];
  } else {
    [_initInvocation invokeWithTarget:_object];
    [_initInvocation getReturnValue:&amp;_object];
    _initInvocation = nil;
  }
}

- (id)forwardingTargetForSelector:(SEL)selector {
  if (_object == nil) {  // once set, fast forwarding is in effect
    if (![NSStringFromSelector(selector) hasPrefix:@"init"]) {
      [self instantiateObject];
    }
  }
  return _object;
}

- (NSMethodSignature *)methodSignatureForSelector:(SEL)selector {
  NSMethodSignature *signature =
      [_objectClass instanceMethodSignatureForSelector:selector];
  return signature;
}

// If we got here, it had to be from an init method
- (void)forwardInvocation:(NSInvocation *)invocation {
  _initInvocation = invocation;
  [_initInvocation setTarget:nil];  // not needed, and we don't want to retain
  [_initInvocation retainArguments];
  // For the immediate init(With...) call, return the proxy itself
  [_initInvocation setReturnValue:(void *)&amp;self];
}

//----------------------------------------------------------------------------
// Implemented by NSProxy, so we need to forward these manually
//----------------------------------------------------------------------------

- (Class)class {
  if (_object == nil) {
    [self instantiateObject];
  }
  return [_object class];
} 

- (Class)superclass {
  if (_object == nil) {
    [self instantiateObject];
  }
  return [_object superclass];
}

- (BOOL)conformsToProtocol:(Protocol *)aProtocol {
  if (self-&gt;_object == nil) {
    [self instantiateObject];
  }
  return [self-&gt;_object conformsToProtocol:aProtocol];
}

- (NSString *)description {
  if (self-&gt;_object == nil) {
    [self instantiateObject];
  }
  return [self-&gt;_object description];
}

- (NSUInteger)hash {
  if (self-&gt;_object == nil) {
    [self instantiateObject];
  }
  return [self-&gt;_object hash];
}

- (BOOL)isEqual:(id)obj {
  if (self-&gt;_object == nil) {
    [self instantiateObject];
  }
  return [self-&gt;_object isEqual:obj];
}

- (BOOL)isKindOfClass:(Class)aClass {
  if (self-&gt;_object == nil) {
    [self instantiateObject];
  }
  return [self-&gt;_object isKindOfClass:aClass];
}

- (BOOL)isMemberOfClass:(Class)aClass {
  if (self-&gt;_object == nil) {
    [self instantiateObject];
  }
  return [self-&gt;_object isMemberOfClass:aClass];
}

- (BOOL)respondsToSelector:(SEL)selector {
  if (self-&gt;_object == nil) {
    [self instantiateObject];
  }
  return [self-&gt;_object respondsToSelector:selector];
}

@end
</code></pre>

<h2>Eero version</h2>

<p>The Objective-C version can of course be
<a href="http://eerolanguage.org/documentation/index.html#importsincludes">used directly in Eero</a>,
but since this started out as Eero code, you&rsquo;ll find the Eero version below.</p>

<p>(By the way, the ObjC example above was automatically converted to Objective-C
using <a href="https://github.com/eerolanguage/eero/wiki/Translator">Eero&rsquo;s source-source translator</a>
and formatted using <a href="http://clang.llvm.org/docs/ClangFormat.html">clang-format</a>).</p>

<p><em>lazyinit.eeh</em></p>

<pre><code>#import &lt;Foundation/Foundation.h&gt;

interface Object (LazyInitialization)
  +lazy, return instancetype
end
</code></pre>

<p><em>lazyinit.eero</em></p>

<pre><code>#import &lt;Foundation/Foundation.h&gt;
#import 'lazyinit.eeh'

#if !__has_feature(objc_arc)
  #error ARC must be enabled for this source file (but clients can use MRC).
#endif

interface LazyProxy : Proxy
  initWithClass: Class, return instancetype   
end

implementation Object (LazyInstantiation)
  +lazy, return instancetype
    return (id)LazyProxy.alloc.initWithClass: self.class
end

implementation LazyProxy 
  id _object
  Class _objectClass
  Invocation _initInvocation

  initWithClass: Class cls, return instancetype
    _objectClass = cls
    return self

  instantiateObject
    _object = _objectClass.alloc
    if _initInvocation == nil // allow SomeClass.lazy (no explicit init)
      _object = _object.init
    else
      _initInvocation.invokeWithTarget: _object
      _initInvocation.getReturnValue: &amp;_object
      _initInvocation = nil

  forwardingTargetForSelector: SEL, return id
    if _object == nil // once set, fast forwarding is in effect
      if not StringFromSelector(selector).hasPrefix: 'init'
        self.instantiateObject
    return _object

  methodSignatureForSelector: SEL, return MethodSignature
    signature := _objectClass.instanceMethodSignatureForSelector: selector 
    return signature

  // If we got here, it had to be from an init method
  forwardInvocation: Invocation
    _initInvocation = invocation
    _initInvocation.setTarget: nil // not needed, and we don't want to retain
    _initInvocation.retainArguments
    // For the immediate init(With...) call, return the proxy itself
    _initInvocation.setReturnValue: (void*)&amp;self

  //--------------------------------------------------------------------------
  // Implemented by NSProxy, so we need to forward these manually
  //--------------------------------------------------------------------------

  -class, return Class
    if _object == nil  
      self.instantiateObject
    return _object.class

  -superclass, return Class
    if _object == nil  
      self.instantiateObject
    return _object.superclass

  conformsToProtocol: Protocol aProtocol, return BOOL
    if _object == nil  
      self.instantiateObject
    return _object.conformsToProtocol: aProtocol

  description, return String
    if _object == nil  
      self.instantiateObject
    return _object.description

  hash, return UInteger
    if _object == nil  
      self.instantiateObject
    return _object.hash

  isEqual: id obj, return BOOL
    if _object == nil  
      self.instantiateObject
    return _object.isEqual: obj

  isKindOfClass: Class aClass, return BOOL
    if _object == nil  
      self.instantiateObject
    return _object.isKindOfClass: aClass

  isMemberOfClass: Class aClass, return BOOL
    if _object == nil  
      self.instantiateObject
    return _object.isMemberOfClass: aClass

  respondsToSelector: SEL, return BOOL
    if _object == nil  
      self.instantiateObject
    return _object.respondsToSelector: selector

end
</code></pre>

<p>So there you have it. Please feel free to
<a href="https://twitter.com/intent/tweet?text=@andyarvanitis%20">provide feedback via twitter</a>.
I also plan to submit the resulting library to <a href="http://cocoapods.org/">Cocoapods</a>.</p>
]]></content>
  </entry>
  
</feed>
